diff --git a/lib/DtSvc/DtUtil1/SmUtil.c b/lib/DtSvc/DtUtil1/SmUtil.c
index 3fa75b7c6..af4a83b22 100644
--- a/lib/DtSvc/DtUtil1/SmUtil.c
+++ b/lib/DtSvc/DtUtil1/SmUtil.c
@@ -176,10 +176,23 @@ getSessionPath(
 
    /*
     * NOTE: it is assumed that _DtCreateDtDirs() returns a buffer of 
-    *       size MAXPATHLEN+1. This allows us to avoid a extra alloc
+    *       size MAXPATHLEN. This allows us to avoid a extra alloc
     *       and copy -- at the expense of code maintainability.
+    *
+    * JET - 2020.  This is stupid.  At least account for the strings
+    * you are adding further on down...  This "solution" isn't great
+    * either.  Real fix would be to have all callers pass in bufptr
+    * and len all the way down the chain instead of tmpPath.
     */
-    if ((strlen(tmpPath) + 1 + strlen(property)) > MAXPATHLEN) goto abort;
+    if ((strlen(tmpPath)
+         + 1 /* "/" */
+         + strlen(property)
+         + 1 /* "/" */
+         + ((*saveFile == NULL) ? strlen("dtXXXXXX") + 1 : strlen(*saveFile))
+        ) >= MAXPATHLEN)
+    {
+        goto abort;
+    }
 
    /* 
     * parse the property string and create directory if needed 
diff --git a/lib/DtSvc/DtUtil2/SmCreateDirs.c b/lib/DtSvc/DtUtil2/SmCreateDirs.c
index 81308c42a..4e8c0b114 100644
--- a/lib/DtSvc/DtUtil2/SmCreateDirs.c
+++ b/lib/DtSvc/DtUtil2/SmCreateDirs.c
@@ -83,33 +83,32 @@ char *
 _DtCreateDtDirs(
         Display *display )
 {
-    char 		*tmpPath;
+    char 		*tmpPath = NULL;
     Boolean 		needSessionsDir = False;
     Boolean 		useOldSession = False;
     struct stat 	buf;
     int 		status;
-    char 		*home;
-    char		*sessionDir;
-    char		*displayName;
+    char 		*home = NULL;
+    char		*sessionDir = NULL;
+    char		*displayName = NULL;
 
     /*
      * Sanity check - make sure there's an existing display
      */
     if(!display)
 	return(NULL);
-    
-    if ((home =getenv("HOME")) == NULL)
+
+    if ((home = getenv("HOME")) == NULL)
         home = "";
-    
-    tmpPath = XtCalloc(1, MAXPATHLEN + 1);
+
+    tmpPath = XtCalloc(1, MAXPATHLEN);
     if(tmpPath == NULL)
 	return(NULL);
 
     /*
      * If the $HOME/.dt directory does not exist, create it
      */
-    strncpy(tmpPath, home, MAXPATHLEN);
-    strncat(tmpPath, "/" DtPERSONAL_CONFIG_DIRECTORY, MAXPATHLEN);
+    snprintf(tmpPath, MAXPATHLEN, "%s/%s", home, DtPERSONAL_CONFIG_DIRECTORY);
 
     status = stat(tmpPath, &buf);
     if (status == -1) {
@@ -122,11 +121,10 @@ _DtCreateDtDirs(
     }
 
     /*
-     * Create the personal DB directory if it does not exist.  
+     * Create the personal DB directory if it does not exist.
      */
-    strncpy(tmpPath, home, MAXPATHLEN);
-    strncat(tmpPath, "/" DtPERSONAL_DB_DIRECTORY, MAXPATHLEN);
-    
+    snprintf(tmpPath, MAXPATHLEN, "%s/%s", home, DtPERSONAL_DB_DIRECTORY);
+
     if ((status = stat (tmpPath, &buf)) == -1) {
         if ((status = mkdir (tmpPath, 0000)) != -1)
 	    (void) chmod (tmpPath, 0755);
@@ -135,8 +133,7 @@ _DtCreateDtDirs(
     /*
      * Create the personal tmp dir if it does not exist.
      */
-    strncpy(tmpPath, home, MAXPATHLEN);
-    strncat(tmpPath, "/" DtPERSONAL_TMP_DIRECTORY, MAXPATHLEN);
+    snprintf(tmpPath, MAXPATHLEN, "%s/%s", home, DtPERSONAL_TMP_DIRECTORY);
 
     if ((status = stat (tmpPath, &buf)) == -1) {
 	if ((status = mkdir (tmpPath, 0000)) != -1)
@@ -173,12 +170,13 @@ _DtCreateDtDirs(
 	     */
 	    if ((displayName = GetDisplayName (display)) != NULL) {
 
-		strncpy (tmpPath, home, MAXPATHLEN);
-		strncat (tmpPath, "/" DtPERSONAL_CONFIG_DIRECTORY, MAXPATHLEN);
-                strncat (tmpPath, "/", MAXPATHLEN);
-                strncat (tmpPath, displayName, MAXPATHLEN);
+                snprintf(tmpPath, MAXPATHLEN, "%s/%s/%s",
+                         home,
+                         DtPERSONAL_CONFIG_DIRECTORY,
+                         displayName);
 
 		free(displayName);  /* CDExc22771 */
+                displayName = NULL;
 
                 if ((status = stat (tmpPath, &buf)) == -1) {
 	            if ((status = mkdir (tmpPath, 0000)) != -1)
@@ -215,12 +213,13 @@ _DtCreateDtDirs(
 	 */
 	if ((displayName = GetDisplayName (display)) != NULL) {
 
-	    strncpy (tmpPath, home, MAXPATHLEN);
-	    strncat (tmpPath, "/" DtPERSONAL_CONFIG_DIRECTORY, MAXPATHLEN);
-	    strncat (tmpPath, "/", MAXPATHLEN);
-	    strncat (tmpPath, displayName, MAXPATHLEN);
+            snprintf(tmpPath, MAXPATHLEN, "%s/%s/%s",
+                     home,
+                     DtPERSONAL_CONFIG_DIRECTORY,
+                     displayName);
 
 	    free(displayName);  /* CDExc22771 */
+            displayName = NULL;
 
 	    if ((status = stat(tmpPath, &buf)) != 0)
 		/*
@@ -238,9 +237,10 @@ _DtCreateDtDirs(
 	 *  If we don't have an old style directory - we check for a sessions
 	 *  directory, and create it if it doesn't exist
 	 */
-	strncpy (tmpPath, home, MAXPATHLEN);
-	strncat (tmpPath, "/" DtPERSONAL_CONFIG_DIRECTORY, MAXPATHLEN);
-	strncat (tmpPath, "/" DtSM_SESSION_DIRECTORY, MAXPATHLEN);
+        snprintf(tmpPath, MAXPATHLEN, "%s/%s/%s",
+                 home,
+                 DtPERSONAL_CONFIG_DIRECTORY,
+                 DtSM_SESSION_DIRECTORY);
 
 	if ((status = stat(tmpPath, &buf)) == -1) {
 	    if ((status = mkdir(tmpPath, 0000)) == -1) {
diff --git a/programs/dtsession/SrvPalette.c b/programs/dtsession/SrvPalette.c
index 75a64b3bf..55b722c96 100644
--- a/programs/dtsession/SrvPalette.c
+++ b/programs/dtsession/SrvPalette.c
@@ -36,26 +36,26 @@ static char rcsid[] =
 **
 **  File:        SrvPalette.c
 **
-**  Project:     HP DT Style Manager , integrated into dtsession
+**  Project:     HP DT Style Manager , integrated into dtsession 
 **
 **  Description:
 **  -----------
 **  This is the main program for the color server portion of the dt session
 **  manager.  It:
-**             1. Determines the number of color cells for each screen
+**             1. Determines the number of color cells for each screen 
 **                attached to the server this session manager is running on.
 **             2. Reads in resouces for the colorserver on a per screen
-**                basis.
+**                basis. 
 **             3. Allocates pixels either Read/Write or Read Only depending
 **                on the resource DynamicColor.
 **             4. Handles query's about those allocated pixels through
-**                Selections.
+**                Selections. 
 **
 *******************************************************************
-**  (c) Copyright Hewlett-Packard Company, 1990.  All rights are
-**  reserved.  Copying or other reproduction of this program
-**  except for archival purposes is prohibited without prior
-**  written consent of Hewlett-Packard Company.
+**  (c) Copyright Hewlett-Packard Company, 1990.  All rights are  
+**  reserved.  Copying or other reproduction of this program      
+**  except for archival purposes is prohibited without prior      
+**  written consent of Hewlett-Packard Company.		     
 ********************************************************************
 **
 **
@@ -118,7 +118,7 @@ static XtResource resources[] = {
         DtRShadowPixmaps,
         sizeof(int),
         XtOffset(AppdataPtr, ShadowPixmaps),
-        XmRString,
+        XmRString, 
         "DEFAULT"},
 
     {   "foregroundColor",
@@ -126,7 +126,7 @@ static XtResource resources[] = {
         DtRForegroundColor,
         sizeof(int),
         XtOffset(AppdataPtr, ForegroundColor),
-        XmRString,
+        XmRString, 
         "DYNAMIC"},
 
     {   "dynamicColor",
@@ -134,7 +134,7 @@ static XtResource resources[] = {
         XmRBoolean,
         sizeof(Boolean),
         XtOffset(AppdataPtr, DynamicColor),
-        XmRImmediate,
+        XmRImmediate, 
         (XtPointer) True},
 
     {   "writeXrdbColors",
@@ -142,7 +142,7 @@ static XtResource resources[] = {
         XmRBoolean,
         sizeof(Boolean),
         XtOffset(AppdataPtr, WriteXrdbColors),
-        XmRImmediate,
+        XmRImmediate, 
         (XtPointer) True},
 
     {   "colorPalette",
@@ -172,12 +172,12 @@ Widget shell[MAX_NUM_SCREENS];
 
 /********    Static Function Declarations    ********/
 
-static Boolean AllocateColors(
+static Boolean AllocateColors( 
                         Display *dpy) ;
 static char *convert_pixel_set(
                         int typeOfMonitor,
                         ColorSet *color );
-static Boolean convert_selection(
+static Boolean convert_selection( 
                         Widget w,
                         Atom *selection,
                         Atom *target,
@@ -185,51 +185,51 @@ static Boolean convert_selection(
                         XtPointer *value,
                         unsigned long *length,
                         int *format) ;
-static void lose_selection(
+static void lose_selection( 
                         Widget w,
                         Atom *selection) ;
-static int FindMaximumDefault(
+static int FindMaximumDefault( 
                         Display *dpy,
                         int screen_number) ;
-static int FindNumOfPixels(
+static int FindNumOfPixels( 
                         Display *dpy,
                         int screen_number) ;
-static int GetNumOfPixels(
+static int GetNumOfPixels( 
                         int screen_number) ;
-static void MatchAndStore(
+static void MatchAndStore( 
                         Display *dpy,
                         int screen_number,
                         unsigned long *pixels) ;
-static Boolean AllocReadWrite(
+static Boolean AllocReadWrite( 
                         Display *dpy,
                         int screen_number,
                         int numOfPixels) ;
-static void AllocReadOnly(
+static void AllocReadOnly( 
                         Display *dpy,
                         int screen_number) ;
-static void CvtStringToColorUse(
+static void CvtStringToColorUse( 
                         XrmValue *args,
                         Cardinal *num_args,
                         XrmValue *from_val,
                         XrmValue *to_val) ;
-static void CvtStringToForegroundColor(
+static void CvtStringToForegroundColor( 
                         XrmValue *args,
                         Cardinal *num_args,
                         XrmValue *from_val,
                         XrmValue *to_val) ;
-static void CvtStringToShadowPixmaps(
+static void CvtStringToShadowPixmaps( 
                         XrmValue *args,
                         Cardinal *num_args,
                         XrmValue *from_val,
                         XrmValue *to_val) ;
-static Boolean _DtWmStringsAreEqual(
+static Boolean _DtWmStringsAreEqual( 
                         register char *in_str,
                         register char *test_str) ;
-static void SetDefaults(
+static void SetDefaults( 
                         Display *dpy,
                         int screen_number) ;
 
-static void _DtCacheProperties(
+static void _DtCacheProperties(	
 			Display *dpy,
 			Window Win) ;
 /********    End Static Function Declarations    ********/
@@ -245,7 +245,7 @@ static void _DtCacheProperties(
  *      for the color server.
  *
  **********************************************************************/
-int
+int 
 InitializeDtcolor(
         Display *dpy,
         short sessionType )
@@ -279,14 +279,14 @@ InitializeDtcolor(
 	return(0);
 
 #ifdef sun
-    OWsyncColorResources(dpy, colorSrv.TypeOfMonitor[0],
+    OWsyncColorResources(dpy, colorSrv.TypeOfMonitor[0], 
 			colorSrv.pCurrentPalette[0]->color);
     OWsyncLocaleResources(dpy);
 #else
-   /* Set the *background: resource
+   /* Set the *background: resource 
        What gets set depends on what type of monitor */
      /* For XmCO_HIGH_COLOR the default primary colorset is 4, else 1 */
-    if(colorSrv.TypeOfMonitor[0] != XmCO_BLACK_WHITE)
+    if(colorSrv.TypeOfMonitor[0] != XmCO_BLACK_WHITE) 
     {
        int chipnum = colorSrv.TypeOfMonitor[0] == XmCO_HIGH_COLOR ? 4 : 1;
        sprintf(xrdb_string,
@@ -299,7 +299,7 @@ InitializeDtcolor(
                       colorSrv.pCurrentPalette[0]->color[chipnum].fg.blue);
 
     }
-     /* For XmCO_BLACK_WHITE the resources depended on whether the default
+     /* For XmCO_BLACK_WHITE the resources depended on whether the default 
         palette is White on Black or Black on White */
     else /* XmCO_BLACK_WHITE */
     {
@@ -317,7 +317,7 @@ InitializeDtcolor(
     }
     /* go merge the xrdb_string into the xrdb */
     _DtAddToResource(dpy, xrdb_string);
-#endif
+#endif    
 
     _DtCacheProperties(dpy, XtWindow(shell[0])) ;
 
@@ -344,18 +344,18 @@ _DtCacheProperties(
        palette->converted = convert_pixel_set(typeOfMonitor, palette->color);
        palette->converted_len = strlen(palette->converted);
      }
-
+  
   *(palette->converted + palette->converted_len) = XmPIXEL_SET_PROP_VERSION ;
   palette->converted_len++ ;
   palette->converted[palette->converted_len] = 0 ;
-  XChangeProperty(dpy, win, pixel_set_atom, XA_STRING, 8, PropModeAppend,
-		 (unsigned char *) XtNewString(palette->converted),
+  XChangeProperty(dpy, win, pixel_set_atom, XA_STRING, 8, PropModeAppend, 
+		 (unsigned char *) XtNewString(palette->converted), 
 		 palette->converted_len) ;
 }
 
 /*****************************************************************************
 **
-**  Allocates color cells to be used by clients.  The global varible
+**  Allocates color cells to be used by clients.  The global varible 
 **  DynamicColor[screen_number] determines if the cells are to be allocated
 **  read/write or read only.  Right now this routine allocates
 **  all cells needed for a palette up front.  For performance tuning we will
@@ -382,7 +382,7 @@ _DtCacheProperties(
 **                                 of Bg
 **
 ***************************************************************************/
-static Boolean
+static Boolean 
 AllocateColors(
         Display *dpy )
 {
@@ -393,7 +393,7 @@ AllocateColors(
     for(screen_number=0;screen_number != colorSrv.NumOfScreens;screen_number++)
     {
        numOfPixels = GetNumOfPixels(screen_number);
-
+ 
    /* Now allocate the correct number of pixels using numOfPixels */
        if(numOfPixels != 0)  /* Not XmCO_BLACK_WHITE */
        {
@@ -406,7 +406,7 @@ AllocateColors(
           else
             /* go allocate Read Only cells for the color server */
              AllocReadOnly(dpy, screen_number);
-       }
+       } 
 
        if(colorSrv.TypeOfMonitor[screen_number] == XmCO_BLACK_WHITE)
        {
@@ -435,7 +435,7 @@ AllocateColors(
 	     WhiteColorSet(dpy,screen_number,palette->color[1].bs);
 	     BlackColorSet(dpy,screen_number,palette->color[1].sc);
           }
-          else
+          else 
           if(!(strcmp(colorSrv.pCurrentPalette[screen_number]->name, B_O_W)))
           {
 	     BlackColorSet(dpy,screen_number,palette->color[0].bg);
@@ -450,7 +450,7 @@ AllocateColors(
 	     BlackColorSet(dpy,screen_number,palette->color[1].bs);
 	     WhiteColorSet(dpy,screen_number,palette->color[1].sc);
           }
-          else
+          else 
           if(!(strcmp(colorSrv.pCurrentPalette[screen_number]->name, W_ONLY)))
           {
 	     WhiteColorSet(dpy,screen_number,palette->color[0].bg);
@@ -484,7 +484,7 @@ AllocateColors(
        }
      XSync(dpy, 0);
    } /* for screen_number=0 ; screen_number < NumOfScreens; screen_number++ */
-
+  
    return(True);
 }
 
@@ -494,21 +494,21 @@ AllocateColors(
 **                screens on the server is running on.
 **
 ************************************************************************/
-int
+int 
 CheckMonitor(
         Display *dpy )
 {
     int n, screen_number, result;
     Arg args[4];
     char screenStr[5], cust_msg[24];
-    char *tmpStr;
-    char            tmpPalette[SRVBUFSIZE];
-    char            *token1;
-    char 	    *xrdb_string;
+    char *tmpStr = NULL;
+    char tmpPalette[SRVBUFSIZE];
+    char *token1 = NULL;
+    char *xrdb_string = NULL;
 
     Widget mainShell;
     XtAppContext app_context;
-
+    
     /* Determine the number of screens attached to this server */
     colorSrv.NumOfScreens = ScreenCount(dpy);
 
@@ -518,67 +518,73 @@ CheckMonitor(
 
    /* create a top level shell to retrieve subresources from */
     n = 0;
-    XtSetArg(args[n], XmNbackground,
+    XtSetArg(args[n], XmNbackground, 
         BlackPixelOfScreen(DefaultScreenOfDisplay(dpy))); n++;
     XtSetArg(args[n], XmNmappedWhenManaged, False); n++;
     XtSetArg (args[n], XmNwidth, 1); n++;
     XtSetArg (args[n], XmNheight, 1); n++;
     mainShell = XtAppCreateShell("dtsession", XmSCOLOR_SRV_NAME,
-                                  applicationShellWidgetClass,
+                                  applicationShellWidgetClass, 
                                   dpy, args, n);
 
    /* create an application context */
     app_context = XtWidgetToApplicationContext(mainShell);
-
+    
    /* Register the resource converters */
-    XtAppAddConverter(app_context, XmRString, "ColorUse",
+    XtAppAddConverter(app_context, XmRString, "ColorUse", 
             CvtStringToColorUse, NULL, 0);
-    XtAppAddConverter(app_context, XmRString, "ForegroundColor",
+    XtAppAddConverter(app_context, XmRString, "ForegroundColor", 
             CvtStringToForegroundColor, NULL, 0);
-    XtAppAddConverter(app_context, XmRString, "ShadowPixmaps",
+    XtAppAddConverter(app_context, XmRString, "ShadowPixmaps", 
             CvtStringToShadowPixmaps, NULL, 0);
 
    /* cycle through each screen */
     for(screen_number=0;screen_number != colorSrv.NumOfScreens;screen_number++)
     {
-       sprintf(screenStr,"%d",screen_number);
+       snprintf(screenStr, sizeof(screenStr), "%d", screen_number);
        n = 0;
-       XtSetArg(args[n], XmNbackground,
+       XtSetArg(args[n], XmNbackground, 
            BlackPixelOfScreen(DefaultScreenOfDisplay(dpy))); n++;
        XtSetArg(args[n], XmNmappedWhenManaged, False); n++;
        XtSetArg (args[n], XmNwidth, 1); n++;
        XtSetArg (args[n], XmNheight, 1); n++;
-       shell[screen_number] = XtAppCreateShell(screenStr, XmSCOLOR_SRV_NAME,
-                                               applicationShellWidgetClass,
+       shell[screen_number] = XtAppCreateShell(screenStr, XmSCOLOR_SRV_NAME, 
+                                               applicationShellWidgetClass, 
                                                dpy, args, n);
 
-       /*
-	* widget needs to be realized for the window ID for
-	* selections to work
+       /* 
+	* widget needs to be realized for the window ID for 
+	* selections to work 
 	*/
-
+       
        XtRealizeWidget(shell[screen_number]);
-
-       sprintf(cust_msg,"%s%d", XmSCUSTOMIZE_DATA, screen_number);
-       colorSrv.XA_CUSTOMIZE[screen_number] =
+       
+       snprintf(cust_msg, sizeof(cust_msg), "%s%d",
+                XmSCUSTOMIZE_DATA, screen_number);
+       colorSrv.XA_CUSTOMIZE[screen_number] = 
 	   XInternAtom(dpy, cust_msg, FALSE);
-
+       
        /* go set ownership of the pixel set atoms */
        result = XtOwnSelection(shell[screen_number],
 			       colorSrv.XA_CUSTOMIZE[screen_number],
-			       CurrentTime, convert_selection,
+			       CurrentTime, convert_selection, 
 			       lose_selection, NULL);
-
+  
        if(result == False)
        {
 	   /*
 	    * Don't forget to add length for the extra characters.
 	    */
-	   tmpStr = (char *)SRV_MALLOC(strlen(MSG1) + 25 + 5 + 1 + 1);
-	   sprintf(tmpStr,"%s colorSrv.XA_CUSTOMIZE[%d].\n",
-		   MSG1, screen_number);
-	   _DtSimpleError(XmSCOLOR_SRV_NAME, DtWarning, NULL, tmpStr, NULL);
-	   SRV_FREE(tmpStr);
+           int len = strlen(MSG1) + 25 + 5 + 1 + 1;
+	   tmpStr = (char *)SRV_MALLOC(len);
+           if (tmpStr)
+           {
+               snprintf(tmpStr, len, "%s colorSrv.XA_CUSTOMIZE[%d].\n",
+                        MSG1, screen_number);
+               _DtSimpleError(XmSCOLOR_SRV_NAME, DtWarning, NULL, tmpStr, NULL);
+               SRV_FREE(tmpStr);
+               tmpStr = NULL;
+           }
 	   return(-1);
        }
 
@@ -587,18 +593,18 @@ CheckMonitor(
        XtGetSubresources(mainShell, &pColorSrvRsrc, screenStr, screenStr,
                           resources, XtNumber(resources), NULL, 0);
 
-      /*
-       * Set TypeOfMonitor, UsePixmaps FgColor and
+      /* 
+       * Set TypeOfMonitor, UsePixmaps FgColor and 
        * DynamicColor for this screen
        */
 
        SetDefaults(dpy, screen_number);
-
+       
        if (colorSrv.TypeOfMonitor[screen_number] != XmCO_BLACK_WHITE)
        {
-          colorSrv.pCurrentPalette[screen_number] =
-                (struct _palette *) GetPaletteDefinition(dpy,
-                                     screen_number,
+          colorSrv.pCurrentPalette[screen_number] = 
+                (struct _palette *) GetPaletteDefinition(dpy, 
+                                     screen_number, 
                                      pColorSrvRsrc.ColorPalette);
        }
        else
@@ -608,15 +614,19 @@ CheckMonitor(
                (struct _palette *) SRV_MALLOC( sizeof(struct _palette) + 1 );
 
            /*  allocate enough space for the name */
-           strcpy(tmpPalette, pColorSrvRsrc.MonochromePalette);
-           for (token1=tmpPalette; *token1; token1++);
-           while (token1!=tmpPalette && *token1!='.') token1--;
-	   if (!strcmp(token1,PALETTE_SUFFIX)) *token1 = '\0';
-           colorSrv.pCurrentPalette[screen_number]->name =
+           snprintf(tmpPalette, SRVBUFSIZE, "%s",
+                    pColorSrvRsrc.MonochromePalette);
+           for (token1=tmpPalette; *token1; token1++)
+               ;
+           while (token1 != tmpPalette && *token1 != '.')
+               token1--;
+	   if (!strcmp(token1, PALETTE_SUFFIX))
+               *token1 = '\0';
+           colorSrv.pCurrentPalette[screen_number]->name = 
                (char *)SRV_MALLOC(strlen(tmpPalette) + 1);
            strcpy(colorSrv.pCurrentPalette[screen_number]->name,
                   (char *) tmpPalette);
-           colorSrv.pCurrentPalette[screen_number]->converted=NULL;
+           colorSrv.pCurrentPalette[screen_number]->converted = NULL;
        }
 
        if (colorSrv.pCurrentPalette[screen_number] == (struct _palette *) NULL)
@@ -627,19 +637,21 @@ CheckMonitor(
       /* write out the color or monochrome palette resource for the screen */
 
        xrdb_string = XtMalloc(BUFSIZ);
+       if (!xrdb_string)
+           return -1;
 
-       if (colorSrv.TypeOfMonitor[0] == XmCO_HIGH_COLOR ||
+       if (colorSrv.TypeOfMonitor[0] == XmCO_HIGH_COLOR || 
            colorSrv.TypeOfMonitor[0] == XmCO_MEDIUM_COLOR ||
            colorSrv.TypeOfMonitor[0] == XmCO_LOW_COLOR)
        {
-           sprintf(xrdb_string, "*%d*ColorPalette: %s%s\n",
+           snprintf(xrdb_string, BUFSIZ, "*%d*ColorPalette: %s%s\n",
                    screen_number,
 		   colorSrv.pCurrentPalette[screen_number]->name,
 		   PALETTE_SUFFIX);
        }
        else /* XmCO_BLACK_WHITE */
        {
-           sprintf(xrdb_string, "*%d*MonochromePalette: %s%s\n",
+           snprintf(xrdb_string, BUFSIZ, "*%d*MonochromePalette: %s%s\n",
                    screen_number,
 		   colorSrv.pCurrentPalette[screen_number]->name,
 		   PALETTE_SUFFIX);
@@ -689,23 +701,23 @@ convert_pixel_set(
     case XmCO_MEDIUM_COLOR: colormappingindex = 1; break;
     case XmCO_LOW_COLOR:    colormappingindex = 2; break;
     case XmCO_BLACK_WHITE:  colormappingindex = 3; break;
-  }
+  } 
 
   p = converted = (char *)SRV_MALLOC(400);
-
+ 
   /* lead the string with the type of monitor */
   p += sprintf(p, "%x_", typeOfMonitor);
 
   for (i = 0; i < NUM_OF_COLORS; i++)
   {
-    p += sprintf (p, "%lx_%lx_%lx_%lx_%lx_",
+    p += sprintf (p, "%lx_%lx_%lx_%lx_%lx_", 
                   color[colormapping[colormappingindex][i]].bg.pixel,
                   color[colormapping[colormappingindex][i]].fg.pixel,
                   color[colormapping[colormappingindex][i]].ts.pixel,
                   color[colormapping[colormappingindex][i]].bs.pixel,
                   color[colormapping[colormappingindex][i]].sc.pixel);
   }
-
+ 
   return(converted);
 }
 
@@ -715,7 +727,7 @@ convert_pixel_set(
 **        to get information from the dtcolor (color server)
 **
 ************************************************************************/
-static Boolean
+static Boolean 
 convert_selection(
         Widget w,
         Atom *selection,
@@ -736,7 +748,7 @@ convert_selection(
   Boolean status;
   struct _palette *palette;
   int typeOfMonitor;
-
+                    
 
   /* Determine for which screen the selection came from */
   for(i=0; i < MAX_NUM_SCREENS; i++)
@@ -789,11 +801,11 @@ convert_selection(
 /************************************************************************
 **
 ** lose_selection - Callback, called when some other client wishes
-**        to take ownership of one of the servers selections ...
+**        to take ownership of one of the servers selections ... 
 **        should never happen.
 **
 ************************************************************************/
-static void
+static void 
 lose_selection(
         Widget w,
         Atom *selection )
@@ -804,19 +816,15 @@ lose_selection(
      pixel_set_atom = XInternAtom(XtDisplay(w), XmSPIXEL_SET_PROP, FALSE) ;
      XDeleteProperty(XtDisplay(w), XtWindow(shell[0]), pixel_set_atom) ;
 
+     tmpStr = (char *)SRV_MALLOC(strlen(MSG2) + strlen(MSG2a) +  6);
+     tmpStr2 = (char *)SRV_MALLOC(strlen(MSG2) + 1);
      if (selection != NULL) {
           tmpStr3 = XGetAtomName(XtDisplay(w), *selection);
      } else {
-          tmpStr3 = "(null)";
+          tmpStr3 = NULL;
      }
-
-     const int str1len = strlen(MSG2) + strlen(MSG2a) + strlen(tmpStr3) + 10;
-     const int str2len = strlen(MSG2) + 1;
-     tmpStr = (char *)SRV_MALLOC(str1len);
-     tmpStr2 = (char *)SRV_MALLOC(str2len);
-
-     snprintf(tmpStr2, str2len, "%s", MSG2);
-     snprintf(tmpStr, str1len, "%s %s\n%s", tmpStr2, tmpStr3, MSG2a);
+     printf(tmpStr2,"%s", MSG2);
+     sprintf(tmpStr,"%s%s%s", tmpStr2, (tmpStr3 == NULL) ? "(null)" : tmpStr3, MSG2a);
      _DtSimpleError(XmSCOLOR_SRV_NAME, DtWarning, NULL, tmpStr, NULL);
      SRV_FREE(tmpStr);
      SRV_FREE(tmpStr2);
@@ -829,8 +837,8 @@ lose_selection(
 ** are available .. this finds and allocates the maximum that are available
 ** It also adjusts TypeOfMonitor, UsePixmaps, and FgColor accordingly.
 **
-******************************************************************************/
-static int
+******************************************************************************/ 
+static int 
 FindMaximumDefault(
         Display *dpy,
         int screen_number )
@@ -858,7 +866,7 @@ FindMaximumDefault(
    }
    else if(colorSrv.TypeOfMonitor[screen_number] == XmCO_HIGH_COLOR)
    {
-       if(numOfPixelsLeft >= 32) /* was asking for 40 */
+       if(numOfPixelsLeft >= 32) /* was asking for 40 */ 
        {
           colorSrv.UsePixmaps[screen_number] = FALSE;
           colorSrv.FgColor[screen_number] = WHITE;
@@ -869,13 +877,13 @@ FindMaximumDefault(
           colorSrv.UsePixmaps[screen_number] = TRUE;
           colorSrv.FgColor[screen_number] = DYNAMIC;
           return(24);
-       }
+       } 
        else if(numOfPixelsLeft >= 16)
        {
           colorSrv.UsePixmaps[screen_number] = TRUE;
           colorSrv.FgColor[screen_number] = WHITE;
           return(16);
-       }
+       } 
        else  /* can't use XmCO_HIGH_COLOR anymore so set to
 		next highest XmCO_MEDIUM_COLOR */
        {
@@ -885,7 +893,7 @@ FindMaximumDefault(
     }
 
    /* need to do an if instead of an else because TypeOfMonitor can be reset
-      in the else if above */
+      in the else if above */     
     if(colorSrv.TypeOfMonitor[screen_number] == XmCO_MEDIUM_COLOR)
     {
        if(numOfPixelsLeft >= 16)
@@ -907,7 +915,7 @@ FindMaximumDefault(
           return(8);
        }
        else /* can't use XmCO_MEDIUM_COLOR anymore so set to next */
-	    /* highest XmCO_LOW_COLOR*/
+	    /* highest XmCO_LOW_COLOR*/ 
        {
           colorSrv.TypeOfMonitor[screen_number] = XmCO_LOW_COLOR;
           colorSrv.pCurrentPalette[screen_number]->num_of_colors = 2;
@@ -916,7 +924,7 @@ FindMaximumDefault(
     }
 
    /* need to do an if instead of an else because TypeOfMonitor can be reset
-      in the else if above */
+      in the else if above */     
     if(colorSrv.TypeOfMonitor[screen_number] == XmCO_LOW_COLOR)
     {
        if(numOfPixelsLeft >= 10)
@@ -955,7 +963,7 @@ FindMaximumDefault(
 ** Maximum default for the user
 **
 ******************************************************************************/
-static int
+static int 
 FindNumOfPixels(
         Display *dpy,
         int screen_number )
@@ -1019,7 +1027,7 @@ FindNumOfPixels(
 **        and ForegroundColor(FgColor).
 **
 ************************************************************************/
-static int
+static int 
 GetNumOfPixels(
         int screen_number )
 {
@@ -1032,7 +1040,7 @@ GetNumOfPixels(
    {
       if(colorSrv.UsePixmaps[screen_number] == FALSE)
       {
-         if(colorSrv.FgColor[screen_number] == DYNAMIC)
+         if(colorSrv.FgColor[screen_number] == DYNAMIC) 
          {
             return(colorSrv.pCurrentPalette[screen_number]->num_of_colors * 5);
          }
@@ -1062,7 +1070,7 @@ GetNumOfPixels(
 **        correctly at the X server.
 **
 ************************************************************************/
-static void
+static void 
 MatchAndStore(
         Display *dpy,
         int screen_number,
@@ -1075,7 +1083,7 @@ MatchAndStore(
    p = colorSrv.pCurrentPalette[screen_number];
    xcolor = (XColor *)SRV_MALLOC (p->num_of_colors * 5 * sizeof (XColor));
 
-   for(i = 0; i < p->num_of_colors; i++)
+   for(i = 0; i < p->num_of_colors; i++) 
    {
       /* Background Pixel */
       p->color[i].bg.pixel = pixels[count];
@@ -1151,7 +1159,7 @@ MatchAndStore(
 **        the varibles TypeOfMonitor, UsePixmaps, and FgColor accordingly.
 **
 ************************************************************************/
-static Boolean
+static Boolean 
 AllocReadWrite(
         Display *dpy,
         int screen_number,
@@ -1169,7 +1177,7 @@ AllocReadWrite(
    status = XAllocColorCells (dpy, DefaultColormap(dpy, screen_number),
                               (Boolean)0, &plane_mask, 0, pixels, numOfPixels);
 
-  /* When status is false means the alloc couldn't get all the pixels
+  /* When status is false means the alloc couldn't get all the pixels 
     the user wanted or what the default is .. so lets go find the
     minumum and set up and use that */
    if(status == False)
@@ -1212,22 +1220,22 @@ AllocReadWrite(
         XStoreColors to set the RGB values of them */
       MatchAndStore(dpy, screen_number, pixels);
 
-   }
+   } 
 
   /* free the allocated space for pixels */
    SRV_FREE((char *) pixels);
    return(True);
-}
+} 
 
 /************************************************************************
 **
 ** AllocReadOnly - Allocates Read Only cells for use by the color
 **        server.  If the X server can't allocate the cell it finds the
 **        closest approximation to the color of a cell already allocated.
-**        Therefore there is no error recorded.
+**        Therefore there is no error recorded.  
 **
 ************************************************************************/
-static void
+static void 
 AllocReadOnly(
         Display *dpy,
         int screen_number )
@@ -1270,14 +1278,14 @@ AllocReadOnly(
          colorSrv.pCurrentPalette[screen_number]->color[i].fg.pixel =
                                           WhitePixel(dpy,screen_number);
    }
-}
+} 
 
 /*********************************************************************
 **
-** Converter which converts a string to the ColorUse value
+** Converter which converts a string to the ColorUse value 
 **
 **********************************************************************/
-static void
+static void 
 CvtStringToColorUse(
         XrmValue *args,
         Cardinal *num_args,
@@ -1309,10 +1317,10 @@ CvtStringToColorUse(
 }
 /**********************************************************************
 **
-** Converter which converts a string to the ForegroundColor value
+** Converter which converts a string to the ForegroundColor value 
 **
 **********************************************************************/
-static void
+static void 
 CvtStringToForegroundColor(
         XrmValue *args,
         Cardinal *num_args,
@@ -1341,10 +1349,10 @@ CvtStringToForegroundColor(
 
 /***********************************************************************
 **
-** Converter which converts a string to the ShadowPixmaps value
+** Converter which converts a string to the ShadowPixmaps value 
 **
 ***********************************************************************/
-static void
+static void 
 CvtStringToShadowPixmaps(
         XrmValue *args,
         Cardinal *num_args,
@@ -1379,7 +1387,7 @@ CvtStringToShadowPixmaps(
  *      responsibility to ensure that test_str is already lower cased.
  *
  ************************************************************************/
-static Boolean
+static Boolean 
 _DtWmStringsAreEqual(
         register char *in_str,
         register char *test_str )
@@ -1407,16 +1415,16 @@ _DtWmStringsAreEqual(
       test_str++;
    }
 }
-
+  
 /************************************************************************
  *
  * SetDefaults - set the TypeOfMonitor, UsePixmaps, FgColor, and DynamicColor
  *       for the screen passed in.  Use the resource values, the number of
- *       colors for this screen, and the visual type of the screen to
+ *       colors for this screen, and the visual type of the screen to 
  *       determine which values best fit.
  *
  *************************************************************************/
-static void
+static void 
 SetDefaults(
         Display *dpy,
         int screen_number )
@@ -1442,13 +1450,13 @@ SetDefaults(
    {
       if ((visual->class == GrayScale) || (visual->class == StaticGray))
       {
-          pColorSrvRsrc.ColorPalette =
+          pColorSrvRsrc.ColorPalette = 
                 XtMalloc(strlen(DEFAULT_GRAYSCALE_PALETTE)+1);
           strcpy(pColorSrvRsrc.ColorPalette, DEFAULT_GRAYSCALE_PALETTE);
       }
       else
       {
-          pColorSrvRsrc.ColorPalette =
+          pColorSrvRsrc.ColorPalette = 
                 XtMalloc(strlen(DEFAULT_COLOR_PALETTE)+1);
           strcpy(pColorSrvRsrc.ColorPalette, DEFAULT_COLOR_PALETTE);
       }
@@ -1457,7 +1465,7 @@ SetDefaults(
    numPlanes = XDisplayPlanes(dpy, screen_number);
 
    if( numPlanes < 3) /* 1 or 2 planes */
-   {
+   { 
       colorSrv.TypeOfMonitor[screen_number] = XmCO_BLACK_WHITE;
       colorSrv.DynamicColor[screen_number] = False;
    }
@@ -1500,8 +1508,8 @@ SetDefaults(
          case XmCO_HIGH_COLOR:
            /* for 5 planes ColorUse = hi_color shadowPixmaps have to be True */
             pColorSrvRsrc.ShadowPixmaps = -1;
-            colorSrv.TypeOfMonitor[screen_number] = XmCO_HIGH_COLOR;
-            break;
+            colorSrv.TypeOfMonitor[screen_number] = XmCO_HIGH_COLOR; 
+            break; 
          case XmCO_MEDIUM_COLOR:
             colorSrv.TypeOfMonitor[screen_number] = XmCO_MEDIUM_COLOR;
             break;
